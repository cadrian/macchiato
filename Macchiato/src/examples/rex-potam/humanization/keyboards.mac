#!/usr/bin/macchiato
/*
 * This file is part of Macchiato.
 *
 * Macchiato is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * Macchiato is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Macchiato.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
 * This is the humanization for keyboards.
 */

import itf "interface.mac";
import utl "utils.mac";

def humanize(value, anchor, percent) {
    if value == 0 {
        result = 0;
    } else {
        result = utl.Anchored(value, anchor, percent);
        if result <= 0 {
            result = 1;
        }
    }
}

def range(bpm) {
    result = bpm / 5;
    if result < 10 {
        result = 10;
    }
}

def tick(event, bpm, sign, canCollide) {
    local r = range(bpm);
    if (sign == 0) {
        // +/- 10% bpm
        result = event.Tick + random(r) - r;
    } else {
        // 10% bpm * sign with a slight offset to allow small collisions
        local t = random(r / 2);
        if canCollide {
            t = t - random(r / 8);
        }
        result = event.Tick + t * sign;
    }
    if result < 1 {
        result = 1;
    }
}

class KeyboardsHumanizer (itf.Humanizer) {

    tracknum;
    portamento;
    velocity;
    expression;
    volume;
    running;
    notes;
    bpm;

    def KeyboardsHumanizer() {
        tracknum = 0;
    }

    def StartSequence() {
        print("Running keyboards humanizer");
    }

    def EndSequence() {
        write("record", record);
        write("notes", notes);
    }

    def StartTrack() {
        // velocity records the current velocity, per channel, per pitch
        velocity = [[], [], [], [], [], [], [], [],
                    [], [], [], [], [], [], [], []];

        // expression records the current expression, per channel
        expression = [127, 127, 127, 127, 127, 127, 127, 127,
                      127, 127, 127, 127, 127, 127, 127, 127];

        // volume records the current expression, per channel
        volume = [127, 127, 127, 127, 127, 127, 127, 127,
                  127, 127, 127, 127, 127, 127, 127, 127];

        // running records the currently running notes per channel
        // For each channel, the array index is the pitch of the note;
        // its value is the start tick of the note
        running = [[], [], [], [], [], [], [], [],
                   [], [], [], [], [], [], [], []];

        // notes records the note lengths per track, per channel
        // For each track, each channel, the array index is the start tick of each note;
        // its value is an array: index = pitch, value = length
        notes[tracknum] = [[], [], [], [], [], [], [], [],
                           [], [], [], [], [], [], [], []];

        // Portamento pedal state
        portamento = false;

        // Not set yet
        bpm = 100;
    }

    def EndTrack() {
        record[tracknum] = {
            "velocity": velocity,
            "expression": expression
        };
        tracknum = tracknum + 1;
    }

    def TrackNumber() {
        result = tracknum;
    }

    def Tempo(event) {
        bpm = event.Bpm;
    }

    def NoteOn(event) {
        // Record the velocity
        velocity[event.Channel][event.Pitch] = event.Velocity;

        if (event.Channel == 9) or (volume[event.Channel] > 0) {
            // Emit an event with a velocity that depends on the expression,
            // and with a bit of random for rough "humanization"
            local v = velocity[event.Channel][event.Pitch];
            local e = expression[event.Channel];
            if (v > 0) and (e > 0) {
                v = (humanize(v, v, 10) * e) / 127;
                local t = tick(event, bpm, 1, (running[event.Channel][event.Pitch] exists) and (running[event.Channel][event.Pitch] > 0));
                running[event.Channel][event.Pitch] = t;
                emit NOTE_ON(event.Channel, event.Pitch, v) at t;
            } else {
                velocity[event.Channel][event.Pitch] = 0;
            }
        }
    }

    def NoteOnOff(event) {
        if (event.Channel != 9) and (volume[event.Channel] == 0) {
            next;
        }

        // Emit an event with a velocity that depends on the expression,
        // and with a bit of random for rough "humanization"
        // Note that expression may have changed so the release velocity is not
        // necessarily equal to the press velocity
        local t = tick(event, bpm, -1, (running[event.Channel][event.Pitch] exists) and (running[event.Channel][event.Pitch] > 0));
        if portamento {
            velocity[event.Channel][event.Pitch] = t;
            emit NOTE_ON(event.Channel, event.Pitch, 0) at t;
        } else if velocity[event.Channel][event.Pitch] > 0 {
            local v = velocity[event.Channel][event.Pitch];
            local e = expression[event.Channel];
            v = (humanize(v, v, 10) * e) / 127;
            record_note_length(event.Channel, event.Pitch, t);
            running[event.Channel][event.Pitch] = -1;
            emit NOTE_OFF(event.Channel, event.Pitch, v) at t;
        }
    }

    def record_note_length(channel, pitch, tick) {
        if running[channel][pitch] exists {
            local start = running[channel][pitch];
            if start > 0 {
                local length = tick - start;
                notes[tracknum][channel][start][pitch] = length;
            }
        }
    }

    def NoteOff(event) {
        // For completion only -- because NoteWorthy Composer
        // does not emit those events

        if (volume[event.Channel] > 0) and (velocity[event.Channel][event.Pitch] > 0) {
            // Emit an event with a velocity that depends on the expression,
            // and with a bit of random for rough "humanization"
            // Note that expression may have changed so the release velocity is not
            // necessarily equal to the press velocity
            local v = (event.Velocity * expression[event.Channel]) / 127;
            v = humanize(v, v, 10);
            local t = tick(event, bpm, -1, (running[event.Channel][event.Pitch] exists) and (running[event.Channel][event.Pitch] > 0));
            record_note_length(event.Channel, event.Pitch, t);
            velocity[event.Channel][event.Pitch] = 0;
            running[event.Channel][event.Pitch] = -1;
            emit NOTE_OFF(event.Channel, event.Pitch, v) at t;
        }
    }

    def Expression(event) {
        // Record the expression value
        expression[event.Channel] = event.Value;
    }

    def Volume(event) {
        // Record the volume value
        volume[event.Channel] = event.Value;
    }

    def Portamento(event) {
        portamento = event.Value
    }

    def PortamentoTime(event) {
        // humanize this event too
        local v = event.Value;
        v = humanize(v, v, 10);
        local t = tick(event, bpm, 0, false);
        emit CONTROL_CHANGE(event.Channel, PORTAMENTO_TIME, v) at t;
    }

}
