#!/usr/bin/macchiato
/*
 * This file is part of Macchiato.
 *
 * Macchiato is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * Macchiato is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Macchiato.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
 * This is the default advanced humanization.
 */

import itf "interface.mac";
import utl "utils.mac";

def humanize(value, anchor, percent) {
    if value == 0 {
        Result = 0;
    } else {
        Result = utl.Anchored(value, anchor, percent);
        if Result < 1 {
            Result = 1;
        } else if (Result > 127) {
            Result = 127;
        }
        System.Print("VELOCITY: " + System.ToString(value) + " (" + System.ToString(percent) + "%) => " + System.ToString(Result))
    }
}

def tick(t, sign, width) {
    if width < 1 {
        Result = t
    } else {
        Result = t + System.GaussRandom(2 * width) + (sign * width);
        if Result < 1 {
            Result = 1;
        }
    }
}

class DefaultHumanizer (itf.Humanizer) {

    tracknum;
    portamento;
    velocity;
    expression;
    volume;
    running;
    notes;
    tickWidth;
    velocityWidth;
    bpm;
    beat;
    chordOn;
    chordOff;

    def DefaultHumanizer() {
        tracknum = 0;
        tickWidth = 20;
        velocityWidth = 20;
        beat = 4;
    }

    def StartSequence() {
        System.Print("Running default humanizer");
    }

    def EndSequence() {
        System.Write("record", record);
        System.Write("notes", notes);
    }

    def StartTrack() {
        // velocity records the current velocity, per channel, per pitch
        velocity = [[], [], [], [], [], [], [], [],
                    [], [], [], [], [], [], [], []];

        // expression records the current expression, per channel
        expression = [127, 127, 127, 127, 127, 127, 127, 127,
                      127, 127, 127, 127, 127, 127, 127, 127];

        // volume records the current expression, per channel
        volume = [127, 127, 127, 127, 127, 127, 127, 127,
                  127, 127, 127, 127, 127, 127, 127, 127];

        // running records the currently running notes per channel
        // For each channel, the array index is the pitch of the note;
        // its value is the start tick of the note
        running = [[], [], [], [], [], [], [], [],
                   [], [], [], [], [], [], [], []];

        // chordOn records the first humanized start tick in a chord
        chordOn = [[], [], [], [], [], [], [], [],
                   [], [], [], [], [], [], [], []];

        // chordOff records the first humanized end tick in a chord
        chordOff = [[], [], [], [], [], [], [], [],
                    [], [], [], [], [], [], [], []];

        // notes records the note lengths per track, per channel
        // For each track, each channel, the array index is the start tick of each note;
        // its value is an array: index = pitch, value = length
        notes[tracknum] = [[], [], [], [], [], [], [], [],
                           [], [], [], [], [], [], [], []];

        // Portamento pedal state
        portamento = false;
    }

    def EndTrack() {
        record[tracknum] = {
            "velocity": velocity,
            "expression": expression
        };
        tracknum = tracknum + 1;
    }

    def TrackNumber() {
        Result = tracknum;
    }

    def Tempo(Event) {
        bpm = Event.Bpm;
        System.Print("TEMPO: " + System.ToString(bpm) + " BPM")
        tickWidth = bpm / (2 * (beat + 1));
        if tickWidth < 1 {
            tickWidth = 1
        }
        System.Print("TICK WIDTH: " + System.ToString(tickWidth))
    }

    def TimeSignature(Event) {
        beat = 2 ^ Event.Denominator;
        System.Print("SIG: " + System.ToString(Event.Numerator) + "/" + System.ToString(beat))
    }

    def NoteOn(Event) {
        // Record the velocity
        velocity[Event.Channel][Event.Pitch] = Event.Velocity;

        if Event.Channel == 9 {
            emit;
        } else if volume[Event.Channel] > 0 {
            // Emit an Event with a velocity that depends on the expression,
            // and with a bit of random for rough "humanization"
            local v = velocity[Event.Channel][Event.Pitch];
            local e = expression[Event.Channel];
            if (v > 0) and (e > 0) {
                v = (humanize(v, v, velocityWidth) * e) / 127;
                local t;
                if chordOn[Event.Channel][Event.Tick] exists {
                    t = tick(chordOn[Event.Channel][Event.Tick], 1, tickWidth / beat);
                } else if chordOff[Event.Channel][Event.Tick] exists {
                    // legato -- be careful not to accumulate "lateness"
                    local l = Event.Tick - chordOff[Event.Channel][Event.Tick]
                    if l <= 0 {
                        l = tickWidth / 2;
                    }
                    t = tick(Event.Tick, 0, l);
                    chordOn[Event.Channel][Event.Tick] = t;
                } else {
                    t = tick(Event.Tick, 1, tickWidth / 2);
                    chordOn[Event.Channel][Event.Tick] = t;
                }
                running[Event.Channel][Event.Pitch] = t;
                System.Print("NOTE ON:  " + System.ToString(Event.Tick) + " => " + System.ToString(t));
                emit NOTE_ON(Event.Channel, Event.Pitch, v) at t;
            } else {
                velocity[Event.Channel][Event.Pitch] = 0;
            }
        }
    }

    def NoteOnOff(Event) {
        if Event.Channel == 9 {
            emit;
        } else if volume[Event.Channel] == 0 {
            // nothing
        } else if portamento {
            local t = tickOff(Event);
            velocity[Event.Channel][Event.Pitch] = t;
            emit NOTE_ON(Event.Channel, Event.Pitch, 0) at t;
        } else if velocity[Event.Channel][Event.Pitch] > 0 {
            local v = velocity[Event.Channel][Event.Pitch];
            noteOff(Event, v);
        }
    }

    def NoteOff(Event) {
        // For completion only -- because NoteWorthy Composer
        // does not emit those Events

        if Event.Channel == 9 {
            emit;
        } else if volume[Event.Channel] == 0 {
            // nothing
        } else if portamento {
            local t = tickOff(Event);
            velocity[Event.Channel][Event.Pitch] = t;
            emit NOTE_ON(Event.Channel, Event.Pitch, 0) at t;
        } else if velocity[Event.Channel][Event.Pitch] > 0 {
            noteOff(Event, Event.Velocity);
        }
    }

    def tickOff(Event) {
        local r = running[Event.Channel][Event.Pitch];

        // Emit an Event with a velocity that depends on the expression,
        // and with a bit of random for rough "humanization"
        // Note that expression may have changed so the release velocity is not
        // necessarily equal to the press velocity
        local w = ((Event.Tick - r) / beat) / 4;
        if w < 1 {
            w = 1;
        } else if w > tickWidth {
            w = tickWidth
        }

        local c;
        local n;

        if chordOff[Event.Channel][Event.Tick] exists {
            c = chordOff[Event.Channel][Event.Tick]
            w = w / (beat + 1)
            n = false
        } else {
            c = Event.Tick
            n = true
        }

        Result = tick(c, -1, w);
        if Result < r {
            Result = tick(c, 0, w);
            if Result < r {
                Result = Event.Tick;
                if Result < r {
                    Result = r + w;
                }
            }
        }

        if n {
            chordOff[Event.Channel][Event.Tick] = Result
        }
    }

    def noteOff(Event, velocity) {
        local t = tickOff(Event);
        local e = expression[Event.Channel];
        local v = (humanize(velocity, velocity, velocityWidth) * e) / 127;
        record_note_length(Event.Channel, Event.Pitch, t);
        System.Print("NOTE OFF: " + System.ToString(Event.Tick) + " => " + System.ToString(t));
        emit NOTE_OFF(Event.Channel, Event.Pitch, v) at t;
    }

    def record_note_length(channel, pitch, tick) {
        local start = running[channel][pitch];
        local length = tick - start;
        notes[tracknum][channel][start][pitch] = length;
    }

    def Expression(Event) {
        // Record the expression value
        expression[Event.Channel] = Event.Value;
    }

    def Volume(Event) {
        // Record the volume value
        volume[Event.Channel] = Event.Value;
    }

    def Portamento(Event) {
        portamento = Event.Value
    }

    def PortamentoTime(Event) {
        // humanize this Event too
        local v = Event.Value;
        v = humanize(v, v, velocityWidth);
        local t = tick(Event.Tick, 0);
        emit CONTROL_CHANGE(Event.Channel, PORTAMENTO_TIME, v) at t;
    }

}
