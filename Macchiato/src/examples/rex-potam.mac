#!/usr/bin/macchiato
/*
 * This file is part of Macchiato.
 *
 * Macchiato is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * Macchiato is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Macchiato.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
 * Advanced example, used by Rex Potam
 * http://rex-potam.cadrian.net/
 *
 * This ruleset fixes a few shortcomings of the MIDI production chain
 * used by the songwriter:
 *
 * - NoteWorthy Composer emits NOTE_ON(velocity=0) instead of NOTE_OFF
 *   events -- replace by NOTE_OFF, except if the PORTAMENTO pedal is on
 *
 * - NoteWorthy Composer emits all tracks, even if they are muted --
 *   an input file may be used to map the actual channels to some
 *   useful value
 *
 * - fluidsynth uses the Expression MPC as a simple volume switch,
 *   whereas Rex uses it for actual dynamics, and rough velocities for
 *   musicality (e.g. strong vs weak beats, musical phrases); these
 *   rules combine the expression and velocity to emit actual note
 *   velocities
 *
 * This also adds a bit of random for "humanization".
 */

import h "rex-potam/humanization.mac";

def loadChannelArray(arg) {
    local p = /map=(?<value>.*)/;
    local m = p.Matcher(arg);
    if m.Matches() {
        local value = m.Group("value");
        channel_array = fromString(value);
    }
}

def loadTracks(arg) {
    local p = /tracks=(?<value>.*)/;
    local m = p.Matcher(arg);
    if m.Matches() {
        local value = m.Group("value");
        tracks = fromString(value);
    }
}

def checkTrackNumber(tn, val) {
    result = val or (tn == humanizer.TrackNumber());
}

def isValidTrack() {
    if tracks.Size() == 0 {
        result = true;
    } else {
        result = tracks.Map(checkTrackNumber, false);
    }
}

def fixEventChannel() {
    if event.Channel exists {
        local c = channel_array[event.Channel]
        if c exists {
            if c < 0 {
                // forget this event as it is not mapped
                next;
            }
            event.Channel = c;
        }
    }
}

true {
    fixEventChannel();
}

BEGIN SEQUENCE {
    channel_array = [];
    tracks = [];
    arguments.ForEach(loadChannelArray);
    arguments.ForEach(loadTracks);
    print("channel_array=" + toString(channel_array));
    print("tracks=" + toString(tracks));
    humanizer = h.LoadHumanizer();
    humanizer.StartSequence();
}

BEGIN TRACK {
    humanizer.StartTrack();
    if (not isValidTrack()) {
        // skip the track
        next;
    }
}

(event.Type == CONTROL_CHANGE) and (event.Mpc == PORTAMENTO) {
    humanizer.Portamento(event);
}

(event.Type == CONTROL_CHANGE) and (event.Mpc == PORTAMENTO_TIME) {
    humanizer.PortamentoTime(event);
    next;
}

(event.Type == CONTROL_CHANGE) and (event.Mpc == EXPRESSION) {
    humanizer.Expression(event);
    next;
}

(event.Type == CONTROL_CHANGE) and (event.Mpc == CHANNEL_VOLUME) {
    humanizer.Volume(event);
    emit;
    next;
}

(event.Type == PROGRAM_CHANGE) {
    // print("Program change on channel " + toString(event.Channel));
}

(event.Type == PROGRAM_CHANGE) and (event.Channel == 9) {
    // Don't emit program change on channel "10" (9 actually)
    print("Ignore program change on drums channel");
    next;
}

(event.Type == NOTE_ON) and (event.Velocity > 0) {
    humanizer.NoteOn(event);
    next;
}

(event.Type == NOTE_ON) and (event.Velocity == 0) {
    humanizer.NoteOnOff(event);
    next;
}

(event.Type == NOTE_OFF) {
    humanizer.NoteOff(event);
    next;
}

(event.Type == TEXT) {
    print("TEXT: " + event.Text);
}

(event.Type == COPYRIGHT) {
    print("COPYRIGHT: " + event.Text);
}

(event.Type == TRACK_NAME) {
    print("TRACK_NAME: " + event.Text);
}

(event.Type == INSTRUMENT_NAME) {
    print("INSTRUMENT_NAME: " + event.Text);
}

(event.Type == LYRICS) {
    print("LYRICS: " + event.Text);
}

(event.Type == MARKER_TEXT) {
    print("MARKER_TEXT: " + event.Text);
}

(event.Type == CUE_POINT) {
    print("CUE_POINT: " + event.Text);
}

END TRACK {
    humanizer.EndTrack();
}

END SEQUENCE {
    humanizer.EndSequence();
}
