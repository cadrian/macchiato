#!/usr/bin/macchiato
/*
 * This file is part of Macchiato.
 *
 * Macchiato is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * Macchiato is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Macchiato.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
 * Advanced example, used by Rex Potam
 * http://www.cadrian.net/rex-potam/
 *
 * This ruleset fixes a few shortcomings of the MIDI production chain
 * used by the songwriter:
 *
 * - NoteWorthy Composer emits NOTE_ON(velocity=0) instead of NOTE_OFF
 *   events
 *
 * - fluidsynth uses the Expression MPC as a simple volume switch,
 *   whereas Rex uses it for actual dynamics, and rough velocities for
 *   musicality (e.g. strong vs weak beats, musical phrases); these
 *   rules combine the expression and velocity to emit actual note
 *   velocities
 *
 * This also adds a bit of random for "humanization".
 */

import h "humanize.mac";

def humanize(value, anchor, percent) {
    result = h.anchored(value, anchor, percent);
}

def initTrack() {
    // velocity records the current velocity, per channel, per pitch
    velocity = [[], [], [], [], [], [], [], [],
                [], [], [], [], [], [], [], []];

    // expression records the current expression, per channel
    expression = [127, 127, 127, 127, 127, 127, 127, 127,
                  127, 127, 127, 127, 127, 127, 127, 127];

    // running records the currently running notes per channel
    // For each channel, the array index is the pitch of the note;
    // its value is the start tick of the note
    running = [[], [], [], [], [], [], [], [],
               [], [], [], [], [], [], [], []];

    // notes records the note lengths per track, per channel
    // For each track, each channel, the array index is the start tick of each note;
    // its value is an array: index = pitch, value = length
    notes[tracknum] = [[], [], [], [], [], [], [], [],
             [], [], [], [], [], [], [], []];
}

def tick(event, sign) {
    // humanize tick, except for the drummer (that sounds drunk)
    if event.channel == 10 {
        result = event.tick;
    } else {
        result = event.tick + random(5) * sign;
    }
}

def note_on(event) {
    // Record the velocity
    velocity[event.channel][event.pitch] = event.velocity;

    // Emit an event with a velocity that depends on the expression,
    // and with a bit of random for rough "humanization"
    local v = (velocity[event.channel][event.pitch] * expression[event.channel]) / 127;
    v = humanize(v, v, 10);
    local t = tick(event, 1);
    running[event.channel][event.pitch] = t;
    emit NOTE_ON(event.channel, event.pitch, v) at t;
}

def record_note_length(channel, pitch, tick) {
    local start = running[channel][pitch];
    local length = tick - start;
    notes[tracknum][channel][start][pitch] = length;
}

def note_on_off(event) {
    // Emit an event with a velocity that depends on the expression,
    // and with a bit of random for rough "humanization"
    // Note that expression may have changed so the release velocity is not
    // necessarily equal to the press velocity
    local v = (velocity[event.channel][event.pitch] * expression[event.channel]) / 127;
    v = humanize(v, v, 10);
    local t = tick(event, -1);
    record_note_length(event.channel, event.pitch, t);
    emit NOTE_OFF(event.channel, event.pitch, v) at t;
}

def note_off(event) {
    // Emit an event with a velocity that depends on the expression,
    // and with a bit of random for rough "humanization"
    // Note that expression may have changed so the release velocity is not
    // necessarily equal to the press velocity
    local v = (event.velocity * expression[event.channel]) / 127;
    v = humanize(v, v, 10);
    local t = tick(event, -1);
    record_note_length(event.channel, event.pitch, t);
    emit NOTE_OFF(event.channel, event.pitch, v) at t;
}

BEGIN SEQUENCE {
    record = [];
    tracknum = 0;
}

BEGIN TRACK {
    initTrack();
}

(event.type == CONTROL_CHANGE) and (event.mpc == EXPRESSION) {
    // Record the expression value
    expression[event.channel] = event.value;
    next;
}

(event.type == NOTE_ON) and (event.velocity > 0) {
    note_on(event);
    next;
}

(event.type == NOTE_ON) and (event.velocity == 0) {
    note_on_off(event);
    next;
}

(event.type == NOTE_OFF) {
    note_off(event);
    next;
}

END TRACK {
    record[tracknum] = {
        "velocity": velocity,
        "expression": expression
    };
    tracknum = tracknum + 1;
}

END SEQUENCE {
    write("record", record);
    write("notes", notes);
}
